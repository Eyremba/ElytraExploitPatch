package com.github.gtavbeastaya;

import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Location;
import org.bukkit.command.Command;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerJoinEvent;
import org.bukkit.event.player.PlayerMoveEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.plugin.java.JavaPlugin;

import java.util.HashMap;
import java.util.UUID;

// Creating hashmaps
public class ElytraExploitPatch extends JavaPlugin implements Listener {
	private HashMap<UUID, Double> aMap = new HashMap<>();
	private HashMap<UUID, Double> YdiagMap = new HashMap<>();
	private HashMap<UUID, Integer> timerMap = new HashMap<>();
	private HashMap<UUID, Integer> violationMap = new HashMap<>();
        private HashMap<UUID, Integer> vlMap = new HashMap<>();
	
	public void onEnable() {
		Bukkit.getServer().getPluginManager().registerEvents(this, this);
	}

	// on a join, the player's UUID is stored in the hashmaps
	@EventHandler(priority = EventPriority.HIGH)
	public void onPlayerJoin(PlayerJoinEvent playerJoinEvent) {
		Player player = playerJoinEvent.getPlayer();
		aMap.put(player.getUniqueId(), 0D);
		YdiagMap.put(player.getUniqueId(), 0D);
		timerMap.put(player.getUniqueId(), 0);
                vlMap.put(player.getUniqueId(), 0);
		violationMap.put(player.getUniqueId(), 0);
	}

	
	//when a player quits, their data is removed from the hashmaps
	@EventHandler(priority = EventPriority.HIGH)
	public void onPlayerJoin(PlayerQuitEvent playerQuitEvent) {
		Player player = playerQuitEvent.getPlayer();
		aMap.remove(player.getUniqueId());
		YdiagMap.remove(player.getUniqueId());
		timerMap.remove(player.getUniqueId());
                vlMap.remove(player.getUniqueId());
		violationMap.remove(player.getUniqueId());
	}

	
	//When a player moves while gliding, the server records their Y position and compares it to one that was recorded about .50 seconds ago
	//If the player's Y's matches up, their movement is cancelled and the Violation Levels go up.
	@EventHandler(priority = EventPriority.MONITOR)
	public void inElytra(PlayerMoveEvent playerMoveEvent) {
		Player player = playerMoveEvent.getPlayer();
		timerMap.put(player.getUniqueId(), timerMap.get(player.getUniqueId()) + 1);
		Location loc = player.getLocation();
		Double Y = loc.getY();
		YdiagMap.put(player.getUniqueId(), Y);
		if (player.isGliding()) {
			String Ya = Y.toString();
			String aA = aMap.get(player.getUniqueId()).toString();
			if (Ya.equals(aA) && violationMap.get(player.getUniqueId()) > 1) {
				vlMap.put(player.getUniqueId(), vlMap.get(player.getUniqueId()) + 1);
                if (!(playerMoveEvent.getFrom().getBlockX() == playerMoveEvent.getTo().getBlockX() && playerMoveEvent.getFrom().getBlockZ() == playerMoveEvent.getTo().getBlockZ())) {
                    notifyStaff(player, vlMap.get(player.getUniqueId()));
                    playerMoveEvent.setTo(playerMoveEvent.getFrom());
                }
				violationMap.put(player.getUniqueId(), 0);
			}
			if(Ya.equals(aA) && !(violationMap.get(player.getUniqueId()) > 1)) {
				violationMap.put(player.getUniqueId(), violationMap.get(player.getUniqueId()) + 1);
			}
		}
	}
	
	//this is the delayed Y recording
	@EventHandler(priority = EventPriority.MONITOR)
	public void getUpdatedY(PlayerMoveEvent playerMoveEvent) {
		Player player = playerMoveEvent.getPlayer();
		if (timerMap.containsKey(player.getUniqueId()) && timerMap.get(player.getUniqueId()) >= 150 & player.isGliding()) {
			Location loc = player.getLocation();
			aMap.put(player.getUniqueId(), loc.getY());
			timerMap.put(player.getUniqueId(), 0);
		}
	}

	
	// 0x22 figured this'd be a nice addition, although it's completely useless on anarchy servers :P
	public void notifyStaff(Player player, int vl) {
	    if (vl > 125) {
            player.kickPlayer(ChatColor.GOLD + "You have been disconnected from the server.");
            for (Player staff : Bukkit.getServer().getOnlinePlayers()) {
                if (staff.isOp() || staff.hasPermission("exp.notify")) {
                    staff.sendMessage(String.format("%s[%s!%s] %s might be using %sElytra Exploit %s(%s / %s)%s. [Kicked]", ChatColor.GRAY, ChatColor.RED, ChatColor.GRAY, player.getDisplayName(), ChatColor.RED, ChatColor.DARK_RED, Math.round(YdiagMap.get(player.getUniqueId())), Math.round(aMap.get(player.getUniqueId())), ChatColor.GRAY));
                }
            }
        } else {
            Bukkit.getServer().getScheduler().scheduleSyncDelayedTask(this, () -> {
                for (Player staff : Bukkit.getServer().getOnlinePlayers()) {
                    if (staff.isOp() || staff.hasPermission("exp.notify")) {
                        staff.sendMessage(String.format("%s[%s!%s] %s might be using %sElytra Exploit %s(%s / %s)%s. [%s]", ChatColor.GRAY, ChatColor.RED, ChatColor.GRAY, player.getDisplayName(), ChatColor.RED, ChatColor.DARK_RED, Math.round(YdiagMap.get(player.getUniqueId())), Math.round(aMap.get(player.getUniqueId())), ChatColor.GRAY, vl));
                    }
                }
            }, 100L);
        }
    }

	//diagnostics
	public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
		if (label.equalsIgnoreCase("elytra")) {
			if (!(sender instanceof Player)) {
				sender.sendMessage(ChatColor.DARK_RED + "You must be a player to use this command!");
				return false;
			}

			Player player = (Player) sender;
			sender.sendMessage(String.format(ChatColor.DARK_RED + "Diagnostics: %s / %s kek", YdiagMap.get(player.getUniqueId()), aMap.get(player.getUniqueId())));
			return true;

		}
		return false;
	}
}
